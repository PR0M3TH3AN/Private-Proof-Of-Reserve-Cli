// private_proof_of_reserve_cli/src/main.rs
// ------------------------------------------------------------
// A *prototype* CLI tool that lets a Bitcoin holder generate a
// **private** proof‑of‑reserve and lets anyone verify it later
// without learning the exact UTXOs or address.
//
// ⚠️  SECURITY NOTICE
// ------------------------------------------------------------
// • This file is a *skeleton* to get you compiling & experimenting.
// • All cryptographic steps marked TODO MUST be audited / replaced
//   by production‑grade equivalents before real funds are involved.
// • At minimum you will need:
//     – a trusted‑hash snapshot of the UTXO set at a chosen height
//     – a circuit or gadget that proves
//          (a) each committed output is in that set (membership)
//          (b) you control the pubkey hash locking it (ownership)
//          (c) Σ value − min_amount ≥ 0 (range / inequality)
// ------------------------------------------------------------

use std::{fs::File, io::Write, path::PathBuf};

use clap::{Parser, Subcommand};
use serde::{Deserialize, Serialize};

//-------------------------------------------------------------
// Crate dependencies (add these to Cargo.toml)
//-------------------------------------------------------------
// [dependencies]
// clap = { version = "4.5", features = ["derive"] }
// bitcoin = "0.31"
// bitcoincore-rpc = "0.18"
// bulletproofs = "4.0"
// curve25519-dalek = "4.2"
// rand = "0.8"
// merkletree = "0.7"
// sha2 = "0.10"
// serde = { version = "1.0", features = ["derive"] }
// serde_json = "1.0"
// hex = "0.4"
//-------------------------------------------------------------

//-------------------------------------------------------------
// CLI definition
//-------------------------------------------------------------

#[derive(Parser, Debug)]
#[command(author, version, about)]
struct Cli {
    #[command(subcommand)]
    cmd: Cmd,
}

#[derive(Subcommand, Debug)]
enum Cmd {
    /// Generate a zero‑knowledge proof that your balance >= min
    Generate {
        /// RPC endpoint for your Bitcoin Core node (txindex=1)
        #[arg(long)]
        rpc_url: String,
        /// RPC username
        #[arg(long)]
        rpc_user: String,
        /// RPC password
        #[arg(long)]
        rpc_pass: String,
        /// Address you control (base58 or bech32)
        #[arg(long)]
        address: String,
        /// Secret key in WIF *or* hex (only for demo!)
        #[arg(long)]
        sk: String,
        /// Minimum amount (sats) you want to prove
        #[arg(long)]
        min: u64,
        /// Block height snapshot
        #[arg(long)]
        height: u64,
        /// Output file for the proof JSON
        #[arg(long, default_value = "proof.json")]
        out: PathBuf,
    },
    /// Verify a proof file against your UTXO snapshot
    Verify {
        /// Proof JSON generated by `generate`
        #[arg(long)]
        proof: PathBuf,
        /// RPC endpoint for *your* view of the chain
        #[arg(long)]
        rpc_url: String,
        #[arg(long)]
        rpc_user: String,
        #[arg(long)]
        rpc_pass: String,
    },
}

//-------------------------------------------------------------
// Minimal proof structure — serialized to JSON
//-------------------------------------------------------------

#[derive(Debug, Serialize, Deserialize)]
struct Proof {
    block_height: u64,
    utxo_root: String,      // hex Merkle root of snapshot
    commitments: Vec<String>,
    range_proof: String,    // base64 bulletproofs
    ownership_proofs: Vec<String>, // Schnorr sigs or ZK gadget proof
    min_amount: u64,
}

//-------------------------------------------------------------
// Main entry
//-------------------------------------------------------------

fn main() -> anyhow::Result<()> {
    let cli = Cli::parse();

    match cli.cmd {
        Cmd::Generate { rpc_url, rpc_user, rpc_pass, address, sk, min, height, out } => {
            let proof = generate_proof(&rpc_url, &rpc_user, &rpc_pass, &address, &sk, min, height)?;
            let mut f = File::create(out)?;
            serde_json::to_writer_pretty(&mut f, &proof)?;
            println!("✅ Proof created ({} commitments)", proof.commitments.len());
        }
        Cmd::Verify { proof, rpc_url, rpc_user, rpc_pass } => {
            let pf: Proof = serde_json::from_reader(File::open(&proof)?)?;
            verify_proof(&pf, &rpc_url, &rpc_user, &rpc_pass)?;
            println!("✅ Proof verified!");
        }
    }

    Ok(())
}

//-------------------------------------------------------------
// Step 1: Fetch UTXOs for the address at the given height
//-------------------------------------------------------------

use bitcoin::{Address, Txid};
use bitcoincore_rpc::{Auth, Client, RpcApi};

#[derive(Debug)]
struct Utxo {
    txid: Txid,
    vout: u32,
    value: u64, // sats
}

fn fetch_utxos(rpc: &Client, addr: &Address, height: u64) -> anyhow::Result<Vec<Utxo>> {
    // NOTE: We rely on listunspent which returns *current* UTXOs.
    // For a real snapshot you must query the UTXO set AS OF `height`.
    // Either spin up a second core node paused at that height or save
    // the assumeUTXO hash and diff. This is left as TODO.
    let unspents = rpc.list_unspent(None, None, Some(&[addr.clone()]), None, None)?;
    let utxos = unspents
        .into_iter()
        .map(|u| Utxo { txid: u.txid, vout: u.vout, value: u.amount.to_sat() })
        .collect();
    Ok(utxos)
}

//-------------------------------------------------------------
// Step 2: Pedersen commitments & Bulletproofs range proof
//-------------------------------------------------------------

use bulletproofs::{BulletproofGens, PedersenGens, RangeProof};
use curve25519_dalek::scalar::Scalar;

fn make_commitments(utxos: &[Utxo]) -> (Vec<[u8; 32]>, Vec<Scalar>, Scalar) {
    let pg = PedersenGens::default();
    let mut rng = OsRng;

    let mut blinding_factors = Vec::new();
    let mut commits = Vec::new();
    let mut total_value = 0u64;

    for u in utxos {
        total_value += u.value;
        let v = Scalar::from(u.value);
        let r = Scalar::random(&mut rng);
        blinding_factors.push(r);
        let c = pg.commit(v, r).compress();
        commits.push(c.to_bytes());
    }

    let total_scalar = Scalar::from(total_value);

    (commits, blinding_factors, total_scalar)
}

//-------------------------------------------------------------
// Step 3: Build Merkle tree of commitments for set‑membership
//-------------------------------------------------------------

use merkletree::{hash::Algorithm, merkle::MerkleTree};
use sha2::Sha256;

#[derive(Clone)]
struct Sha2Algo(Sha256);
impl Default for Sha2Algo { fn default() -> Self { Sha2Algo(Sha256::new()) } }
impl Algorithm<[u8; 32]> for Sha2Algo {
    fn hash(&mut self) -> [u8; 32] { self.0.clone().finalize().into() }
    fn reset(&mut self) { self.0 = Sha256::new(); }
    fn leaf(&mut self, leaf: &[u8; 32]) -> [u8; 32] { Sha256::digest(leaf).into() }
    fn node(&mut self, left: &[u8; 32], right: &[u8; 32]) -> [u8; 32] {
        let mut h = Sha256::new(); h.update(left); h.update(right); h.finalize().into()
    }
}

//-------------------------------------------------------------
// Generate proof (glue code)
//-------------------------------------------------------------

fn generate_proof(rpc_url: &str, rpc_user: &str, rpc_pass: &str, address: &str,
                  sk: &str, min: u64, height: u64) -> anyhow::Result<Proof> {
    // 1. Connect to node
    let rpc = Client::new(rpc_url, Auth::UserPass(rpc_user.to_string(), rpc_pass.to_string()))?;

    // 2. Parse address
    let addr: Address = address.parse()?;

    // 3. Fetch utxos
    let utxos = fetch_utxos(&rpc, &addr, height)?;
    if utxos.is_empty() {
        anyhow::bail!("No UTXOs for address");
    }

    // 4. Pedersen commitments
    let (commitments, blindings, total_scalar) = make_commitments(&utxos);
    if total_scalar < Scalar::from(min) {
        anyhow::bail!("Balance below threshold");
    }

    // 5. Range proof on (total - min) to show ≥ 0
    let diff = (total_scalar - Scalar::from(min)).reduce();
    let pg = PedersenGens::default();
    let bp_gens = BulletproofGens::new(64, 1);
    let mut rng = OsRng;
    let blinding_diff = Scalar::random(&mut rng);
    let commitment_diff = pg.commit(diff, blinding_diff);
    let (range_proof, _) = RangeProof::prove_single(&bp_gens, &pg, &mut rng,
        diff.into(), &blinding_diff, 64)?;

    // 6. Build Merkle tree of commitments (demo: simple, not sorted)
    let tree: MerkleTree<[u8; 32], Sha2Algo> = MerkleTree::from_iter(commitments.clone());
    let root = tree.root();

    // 7. TODO: generate membership proofs for each commitment

    // 8. TODO: prove ownership (Schnorr sig inside circuit or external)

    // Pack proof struct
    let proof = Proof {
        block_height: height,
        utxo_root: hex::encode(root),
        commitments: commitments.iter().map(|c| hex::encode(c)).collect(),
        range_proof: base64::encode(range_proof.to_bytes()),
        ownership_proofs: Vec::new(), // TODO
        min_amount: min,
    };

    Ok(proof)
}

//-------------------------------------------------------------
// Verify proof (glue code)
//-------------------------------------------------------------

fn verify_proof(pf: &Proof, rpc_url: &str, rpc_user: &str, rpc_pass: &str) -> anyhow::Result<()> {
    // 1. Ensure snapshot height exists
    let rpc = Client::new(rpc_url, Auth::UserPass(rpc_user.to_string(), rpc_pass.to_string()))?;
    let best = rpc.get_blockchain_info()?.blocks as u64;
    if best < pf.block_height {
        anyhow::bail!("Node is behind block height of proof");
    }

    // 2. Recompute root from commitments (only works if verifier trusts list)
    //    For real system, verifier must recompute from *membership* proofs.
    let commitments_bytes: Vec<[u8; 32]> = pf.commitments.iter()
        .map(|h| {
            let mut arr = [0u8; 32];
            arr.copy_from_slice(&hex::decode(h).expect("hex"));
            arr
        }).collect();
    let tree: MerkleTree<[u8; 32], Sha2Algo> = MerkleTree::from_iter(commitments_bytes.clone());
    let root = tree.root();
    if hex::encode(root) != pf.utxo_root {
        anyhow::bail!("Merkle root mismatch");
    }

    // 3. Verify range proof
    let pg = PedersenGens::default();
    let bp_gens = BulletproofGens::new(64, 1);
    let range_proof_bytes = base64::decode(&pf.range_proof)?;
    let range_proof = RangeProof::from_bytes(&range_proof_bytes)?;

    // commitment to diff is not published; verifier recomputes via relation
    // TODO: in a real system publish commitment_diff
    // Here we skip and **assume** proof is valid (demo only)
    let _ = range_proof;

    // 4. TODO: verify ownership proofs

    Ok(())
}

//-------------------------------------------------------------
// Helpers
//-------------------------------------------------------------

trait Reduce { fn reduce(self) -> Self; }
impl Reduce for Scalar {
    fn reduce(self) -> Self { self } // dalek scalars are already reduced
}
